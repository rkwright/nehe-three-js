<!DOCTYPE html>
<html lang="en">
<head>
    <!-- -------------------------------------
          Very roughly based (or inspired by) NeHe Tutorial 37
          Original:  http://nehe.gamedev.net/tutorial/cel_shading/25001/
          Largely cloned from https://medium.com/@andrew_b_berg/volumetric-light-scattering-in-three-js-6e1850680a41

          @author: rkwright@geofx.com
    -------------------------------------- -->
    <title>NEHE Lesson 37</title>
    <meta charset="UTF-8"/>

    <!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
    <link rel="stylesheet" type="text/css" href="../css/NEHE.css" />

    <!-- Include several libraries from THREE.js and the Scene class  -->
    <script src="../js/three.js" type="text/javascript"></script>
    <script src="../js/Detector.js" type="text/javascript"></script>
    <script src="../js/OrbitControls-Touch-Ortho.js" type="text/javascript"></script>
    <script src="../js/stats.js" type="text/javascript"></script>
    <script src="../js/gfx-scene.js" type="text/javascript"></script>
    <script src="../js/loaders/VTKLoader.js" type="text/javascript"></script>

    <script src="js/TeapotBufferGeometry.js" type="text/javascript"></script>

    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec3 vNormal;
        varying vec3 vViewPosition;

        void main() {

            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            vNormal = normalize( normalMatrix * normal );
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            vViewPosition = -mvPosition.xyz;
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform vec3 uMaterialColor;

        uniform vec3 uDirLightPos;
        uniform vec3 uDirLightColor;

        uniform float uKd;
        uniform float uBorder;
        uniform float uLevels;
        varying vec3 vNormal;
        varying vec3 vViewPosition;

        void main() {
            // compute direction to light
            vec4 lDirection = viewMatrix * vec4( uDirLightPos, 0.0 );
            vec3 lVector = normalize( lDirection.xyz );

            // diffuse: N * L. Normal must be normalized, since it's interpolated.
            vec3 normal = normalize( vNormal );

            // check the diffuse dot product against uBorder and adjust diffuse value accordingly.
            float diffuse = dot( normal, lVector );

            float sign = diffuse < 0.0 ? -1.0 : 1.0;
            diffuse = (floor((abs(diffuse) + 0.001) * uLevels ) / uLevels) * sign + (1.0 / (uLevels * 2.0));

            gl_FragColor = vec4( uKd * uMaterialColor * uDirLightColor * diffuse, 1.0 );
        }
    </script>
</head>
<body>
<script>
    // global variables  (ick)
    var modelMesh;
    var phongMaterial;
    var nLevels = 4.0;

    // allocate the Scene object, request orbitControls and the stats
    var gfxScene = new GFX.Scene( {
        cameraPos : [10, 10, 6],
        controls:true,
        defaultLights: false,
        displayStats:true
    });

    var N = 4;
    for ( var k=0; k<10; k++ ) {
        var diffus = ((-1 + k * 0.2) + 1) / 2;
        var sign = diffus < 0 ? -1.0 : 1.0;
        var val = (Math.floor((Math.abs(diffus) + 0.001) * N ) / N) * sign + (1 / (N * 2));
        console.log("k: " + k + " diffus: " + diffus.toFixed(2) + " val: " + val.toFixed(3));
    }


    // we can't use the default lights because we need to pass the directional light to the shader
    gfxScene.clearAllLights();
    gfxScene.addLight( 'ambient', { color:0x333333, intensity : 1 });
    var dirLight = gfxScene.addLight( 'directional', { color:0xffffff, intensity:1.0,  position:[-10,10,20]});

    // then initialize our demo's stuff
    initializeDemo();

    // Animate the scene
    animateScene();

    /**
     * Initialize the Demo.
     */
    function initializeDemo() {
        var materialColor = new THREE.Color();
        materialColor.setRGB(1.0, 0.8, 0.6);

        phongMaterial = createShaderMaterial("phongDiffuse", dirLight);

        phongMaterial.uniforms.uMaterialColor.value.copy(materialColor);
        phongMaterial.side = THREE.DoubleSide;

        loadTeapot();

        document.addEventListener("keypress", onDocumentKeyPress, false);
    }

    function createShaderMaterial(id, light) {

        // could be a global, defined once, but here for convenience
        var shaderTypes = {
            'phongDiffuse' : {

                uniforms: {

                    "uDirLightPos": { type: "v3", value: new THREE.Vector3() },
                    "uDirLightColor": { type: "c", value: new THREE.Color( 0xFFFFFF ) },

                    "uMaterialColor": { type: "c", value: new THREE.Color( 0xFFFFFF ) },

                    uKd:     { type: "f", value: 0.9 },
                    uBorder: { type: "f", value: 0.4 },
                    uLevels: { type: "f", value: nLevels }
                }
            }
        };

        var shader = shaderTypes[id];

        var uniforms = THREE.UniformsUtils.clone(shader.uniforms);

        var vs = document.getElementById("vertexShader").textContent;
        var fs = document.getElementById("fragmentShader").textContent;
        var material = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs, fragmentShader: fs });

        material.uniforms.uDirLightPos.value = light.position;
        material.uniforms.uDirLightColor.value = light.color;

        return material;
    }

    function loadTeapot() {

        gfxScene.remove(modelMesh);

        var teapotSize = 3;
        var teapotGeom = new THREE.TeapotBufferGeometry(teapotSize, 20, true, true, true, true);
        modelMesh = new THREE.Mesh( teapotGeom, phongMaterial );
        modelMesh.position.set(0, 1, 0);
        gfxScene.add(modelMesh);

    }

    function loadKnot() {

        var torusGeom = new THREE.TorusKnotGeometry(2.0, 0.5, 100, 16);
        modelMesh = new THREE.Mesh(torusGeom, phongMaterial);
        gfxScene.add(modelMesh);
    }

    // prepare VTK loader and load the model
    function  loadRabbit () {
        var manager = new THREE.LoadingManager();
        var loader = new THREE.VTKLoader( manager );

        // Launch loading of the VTK file, onLoad* will be called when it's ready
        loader.load( 'models/bunny.vtk', onLoadVTK);
    }

    function onLoadVTK ( geometry ) {

        geometry.computeVertexNormals();

        gfxScene.remove(modelMesh);

        modelMesh = new THREE.Mesh(geometry, phongMaterial);
        modelMesh.rotation.set(0, Math.PI/2, 0);
        modelMesh.scale.set(35, 35, 35);
        modelMesh.position.set(-0.15, -2.5, 0);
        gfxScene.add(modelMesh);
    }

    function switchModel ( type ) {

        gfxScene.remove(modelMesh);

        switch (type) {
            case 't':
                loadTeapot();
                break;
            case 'r':
                loadRabbit();
                break;
            case 'k':
                loadKnot();
                break;
        }
    }

    function onDocumentKeyPress(event) {
        // Get the key code of the pressed key
        var keyChar = String.fromCharCode(event.which).toLowerCase();

        var levelString = "2345678";
        var modelString = "trk";

        if ( modelString.indexOf(keyChar) !== -1) {
             switchModel(keyChar);
        }
        else if (levelString.indexOf(keyChar) !== -1) {
            nLevels = keyChar - '0';
        }
    }
    /**
     * Animate the scene and call rendering.
     */
    function animateScene() {

        if (modelMesh !== undefined)
            modelMesh.rotation.y += 0.01;

        // pass the levels value down to the shader
        phongMaterial.uniforms.uLevels.value = nLevels;

        // Map the 3D scene down to the 2D screen (render the frame)
        gfxScene.renderScene();

        // Tell the browser to call this function when page is visible
        requestAnimationFrame(animateScene);
    }

</script>
    <!-- Create a DIV element, which will be shown over the WebGL canvas. -->
    <div style="text-align:center; top: 0px; left: 10px;color:white">
        '0 .. 2': which model
    </div>
</body>
</html>