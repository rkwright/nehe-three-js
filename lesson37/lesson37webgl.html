<!DOCTYPE html>
<html lang="en">
<head>
    <!-- -------------------------------------
          Very roughly based (or inspired by) NeHe Tutorial 37
          Original:  http://nehe.gamedev.net/tutorial/cel_shading/25001/
          Largely cloned from https://medium.com/@andrew_b_berg/volumetric-light-scattering-in-three-js-6e1850680a41

          @author: rkwright@geofx.com
    -------------------------------------- -->
    <title>NEHE Lesson 37</title>
    <meta charset="UTF-8"/>

    <!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
    <link rel="stylesheet" type="text/css" href="../css/NEHE.css" />

    <!-- Include several libraries from THREE.js and the Scene class  -->
    <script src="../js/three.js" type="text/javascript"></script>
    <script src="../js/Detector.js" type="text/javascript"></script>
    <script src="../js/OrbitControls-Touch-Ortho.js" type="text/javascript"></script>
    <script src="../js/stats.js" type="text/javascript"></script>
    <script src="../js/gfx-scene.js" type="text/javascript"></script>

    <script src="js/TeapotBufferGeometry.js"></script>

    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec3 vNormal;
        varying vec3 vViewPosition;

        void main() {

            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            vNormal = normalize( normalMatrix * normal );
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            vViewPosition = -mvPosition.xyz;
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform vec3 uMaterialColor;

        uniform vec3 uDirLightPos;
        uniform vec3 uDirLightColor;

        uniform float uKd;
        uniform float uBorder;

        varying vec3 vNormal;
        varying vec3 vViewPosition;

        void main() {
            // compute direction to light
            vec4 lDirection = viewMatrix * vec4( uDirLightPos, 0.0 );
            vec3 lVector = normalize( lDirection.xyz );

            // diffuse: N * L. Normal must be normalized, since it's interpolated.
            vec3 normal = normalize( vNormal );

            // check the diffuse dot product against uBorder and adjust diffuse value accordingly.
            //float diffuse = max( dot( normal, lVector ), 0.0);
            float diffuse = dot( normal, lVector );


            if ( diffuse > 0.6 ) {
                diffuse = 1.0;
            }
            else if ( diffuse > -0.2 ) {
                diffuse = 0.7;
            }
            else {
                diffuse = 0.3;
            }

            gl_FragColor = vec4( uKd * uMaterialColor * uDirLightColor * diffuse, 1.0 );
        }
    </script>
</head>
<body>
<script>
    // global variables  (ick)
    var model;

    // allocate the Scene object, request orbitControls and the stats
    var gfxScene = new GFX.Scene( {
        cameraPos : [10, 10, 6],
        controls:true,
        defaultLights: false,
        displayStats:true
    });

    // we can't use the default lights because we need to pass the directional light to the shader
    gfxScene.clearAllLights();
    gfxScene.addLight( 'ambient', { color:0x333333, intensity : 1 });
    var dirLight = gfxScene.addLight( 'directional', { color:0xffffff, intensity:1.0,  position:[-10,10,20]});

    // then initialize our demo's stuff
    initializeDemo();

    // Animate the scene
    animateScene();

    /**
     * Initialize the Demo.
     */
    function initializeDemo() {
        var materialColor = new THREE.Color();
        materialColor.setRGB(1.0, 0.8, 0.6);

        var phongMaterial = createShaderMaterial("phongDiffuse", dirLight);

        phongMaterial.uniforms.uMaterialColor.value.copy(materialColor);
        phongMaterial.side = THREE.DoubleSide;

        var teapotSize = 3;
        var teapotGeom = new THREE.TeapotBufferGeometry(teapotSize, 20, true, true, true, true);
        var teapot = new THREE.Mesh( teapotGeom, phongMaterial );
        gfxScene.add(teapot);

        model = teapot;
    }

    function createShaderMaterial(id, light) {

        // could be a global, defined once, but here for convenience
        var shaderTypes = {
            'phongDiffuse' : {

                uniforms: {

                    "uDirLightPos": { type: "v3", value: new THREE.Vector3() },
                    "uDirLightColor": { type: "c", value: new THREE.Color( 0xFFFFFF ) },

                    "uMaterialColor": { type: "c", value: new THREE.Color( 0xFFFFFF ) },

                    uKd: {
                        type: "f",
                        value: 0.7
                    },
                    uBorder: {
                        type: "f",
                        value: 0.4
                    }
                }
            }
        };

        var shader = shaderTypes[id];

        var uniforms = THREE.UniformsUtils.clone(shader.uniforms);

        var vs = document.getElementById("vertexShader").textContent;
        var fs = document.getElementById("fragmentShader").textContent;
        var material = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs, fragmentShader: fs });

        material.uniforms.uDirLightPos.value = light.position;
        material.uniforms.uDirLightColor.value = light.color;

        return material;
    }

    /**
     * Animate the scene and call rendering.
     */
    function animateScene() {

        //model.rotation.x += 0.005;
        model.rotation.y += 0.005;
        //model.rotation.z += 0.005;

        // Map the 3D scene down to the 2D screen (render the frame)
        gfxScene.renderScene();

        // Tell the browser to call this function when page is visible
        requestAnimationFrame(animateScene);
    }

</script>
</body>
</html>